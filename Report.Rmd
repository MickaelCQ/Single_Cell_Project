---
title: "CAF Single cell Transcriptomics Analysis"
author: "Mickael Coquerelle & Loik Galtier"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
  html_document:
    toc: true
    toc_depth: 3
    theme: cerulean
    highlight: tango
    df_print: paged
geometry: margin=1cm
fontsize: 11pt
linestretch: 1.15
bibliography: []
---

```{r setup, echo=TRUE, results="hide", message=FALSE, warning=FALSE}
# Setup global chunk options and libraries.
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.width = 8, fig.height = 6)
# Tidyverse-like utilities
library(dplyr)
library(ggplot2)
# Seurat and single-cell specific tools
library(Seurat)
# Parallelization for Seurat (kept sequential by default in this report for reproducibility)
library(future)
# Annotation via Ensembl
library(AnnotationDbi)
library(EnsDb.Hsapiens.v86)
sessionInfo()
# Parallelisation:
plan(sequential) 
options(future.globals.maxSize=10*1024^3) # 10 GB

```

```{r load, echo=TRUE, results="hide", message=FALSE, warning=FALSE}
" data loading : we load the three datasets corresponding to three different patients' CAF single-cell RNA-seq data. "

p5 <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805570_CountsMatrix_20G00953M_TN.txt.gz", sep="\t")
p4a <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805568_CountsMatrix_19G02977B_TN.txt.gz", sep="\t")
p4b <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805566_CountsMatrix_19G02977A_TN.txt.gz", sep="\t")

```

# Résumé
L'objet de ce travail et de se familiariser avec l'analyse transcriptomique Single-Cell de CAF (Cancer Associated Fibroblasts) à partir d'une matrice de comptages issues des trois fichiers proposé. Notre pipeline d'analyse en se basant sur les éléments donnés en cours couvre le nettoyage (filtrage cellules/gènes), normalisation, réduction de dimension (PCA, t-SNE, UMPAP), clustering, identification de(s) signature(s) transcriptomique(s) pour marquer les clusters et enfin nous proposons une visualisation ciblée par heatmap et features plots.

# Préparation des données.
We combine the three datasets and map Ensembl IDs to gene symbols and types. the objectif is to filter for protein-coding genes with unique symbols and no missing values.
## Pré-processing des données
```{r data-preprocessing, results="hide", message=FALSE, warning=FALSE}
caf.data <- data.matrix(cbind(p5,p4a,p4b))
ens <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/ensembl-38-108-genes.txt", 
                sep="\t")
# map Ensembl IDs to genes symbols and types :
ens2symb <- setNames(ens$Gene.name, ens$Gene.stable.ID) 
ens2type <- setNames(ens$Gene.type, ens$Gene.stable.ID)
symbols <- ens2symb[rownames(caf.data)] # map ensembl IDs to gene symbols

# filter for protein-coding genes with unique symbols and no missing values :
types <- ens2type[rownames(caf.data)] 
# condition filter is defined here 
good <- types=="protein_coding" & !is.na(symbols) & !duplicated(symbols) 
sum(good) # number of genes passing the filter
symb <- symbols[good]
caf.data <- caf.data[good,]
rownames(caf.data) <- symb
```

On crée un premier objet SeuratObject pour tirer profit des routines intégrées à la librairie
(FindVariableFeatures, ScaleData, RunPCA, etc.):

```{r create-seurat-object, results="hide", message=FALSE, warning=FALSE}
caf <- CreateSeuratObject(counts=caf.data, project="cafs",
                          min.cells=0.01*ncol(caf.data), min.features=1000) 
#caf
```

## QC et filtrage des données

Puis on va définir des filtres. La détermination de ces derniers se fait sur des règles d'usage en *single-cell.*
*min.cells = 0.01* au premier passage pour exclures les gènes exprimés dans
très peu de cellules (ici adapté au CreateSeuratObject).
On applique ensuite des QC aux cellules : 
- Les UMIs elevés (>50000) indiquent des duplicats il faut donc les gérer.
- Les cellules avec peu de gènes détectés (< 1000) sont souvent de mauvaise qualité, 
il y'a donc necessité de les filtrer. 
- Ensuite on ajoute une condition pour gérer la proportion de gènes mitochondriaux
élevée (> 50), qui est un indicateur de cellules mortes. 
En combinant ces filtres, on nettoie notre dataset de manière avoir un jeu de cellule
de haute qualité.

```{r qc-filtering, results="hide", message=FALSE, warning=FALSE}
ensdb.genes <- genes(EnsDb.Hsapiens.v86)# extract from ensdb
# mito gene from MT chromosome
MT.names <- ensdb.genes[seqnames(ensdb.genes) == "MT"]$gene_name
counts <- GetAssayData(caf, "RNA") # get the count matrix

# data for cleaning data next
umi.tot   <- colSums(counts)
gene.tot  <- colSums(counts > 0)
sum(rownames(counts) %in% MT.names)

# percent of mito :
mito.pc <- colSums(counts[rownames(counts) %in% MT.names, ]) / umi.tot * 100
bad.high<- umi.tot > 50000 ; bad.low<- gene.tot < 1000 ;bad.mito <- mito.pc > 50

# Disjonction des filtres :
bad <- bad.high | bad.low | bad.mito
' # to check the quantity of removed element
table(bad.high);table(bad.low);table(bad.mito);table(bad)
'
# Nettoyage effectif :
counts <- counts[, !bad] ; counts
good.genes <- rowSums(counts > 1) >= 0.01 * ncol(counts)
counts <- counts[good.genes, ]
dim(counts) #Pour vérifier les dimensions après nettoyage
```
Nous pouvons visualiser la distribution de la proportion de gènes mitochondriaux, avant nettoyage: 

```{histo, message=FALSE, warning=FALSE}
hist(mito.pc, breaks=50)
```

Nous mettons à jour notre objet Seurat avec les données nettoyées :
```{r update-seurat-object, results='hide', message=FALSE, warning=FALSE}
caf <- CreateSeuratObject(counts = counts,
                          project = "CAF_clean",
                          min.cells = 0,
                          min.features = 0)
caf
```

# Normalisation avec SC Transform.
La normalisation etant une étape charnière et pouvant grandement changer les résultats finaux en Single-Cell. Nous avons choisi ici d'exploiter les fonctionnalités de normalisation de la librairie Seurat. Plutôt qu’une normalisation CPM (par millions) ou LogNormalize, nous appliquons ici **SCTransform**, une méthode plus moderne et robuste, qui est construite sur un modèle négatif binomial (Hafemeister & Satija, 2019). De ce que nous en avons compris, une telle approche va agir sur plusieurs aspects : 
- La normalisation par profondeur de séquençage,  
- La stabilisation de variance,  
- La sélection des gènes variables,  
- La correction des effets techniques (ici regression des % mitochondriaux).
Cette méthode est d'après la littérature **la référence Seurat** pour le pré-traitement.

## Le modèle mathématique expliqué.

La normalisation SCTransform repose sur un modèle de **régression négative binomiale**.  
Pour chaque gène \(g\) et chaque cellule \(i\), on suppose : $y_{ig} \sim \text{NB}(\mu_{ig}, \theta_g)$
où \(y_{ig}\) est le nombre de transcripts observés, \(\mu_{ig}\) la moyenne attendue de nos comptes et 
\(\theta_g\) : le paramètre de dispersion du gène \(g\). La moyenne \(\mu_{ig}\) est modélisée via un lien log-linéaire.
\[
\log(\mu_{ig}) = \beta_{0g} + \beta_{1g} \cdot \log(\text{UMI}_i) + \sum_{k} \gamma_{kg} x_{ik}
\]
avec :
- \(\beta_{0g}\) : intercept spécifique au gène \(g\)  
- \(\text{UMI}_i\) : total de counts de la cellule \(i\) (size factor)  
- \(x_{ik}\) : variables techniques à régresser (ex. % mitochondriaux, batch)  
- \(\gamma_{kg}\) : coefficients associés aux covariables
La normalisation finale utilisée pour l'analyse (PCA, clustering) est obtenue via les **résidus Pearson standardisés** :
\[
r_{ig} = \frac{y_{ig} - \hat{\mu}_{ig}}{\sqrt{\hat{\mu}_{ig} + \frac{\hat{\mu}_{ig}^2}{\theta_g}}}
\]

Ces résidus sont **variance-stabilisés** et permettent d'atténuer l'effet de la profondeur de séquençage et du bruit technique.
Avec cette approche, on à \textit{à priori} un modèle individuel pour chaque gène, et une normalisation \og cellule spécifique \fg.

## Application de la méthode
```{r sctransform, message=FALSE, warning=FALSE}
# Calcul du pourcentage mitochondrial pour régression
caf[["percent.mt"]] <- PercentageFeatureSet(
  caf, pattern = "^MT-"
)
# Normalisation moderne SCTransform
caf <- SCTransform(
  caf, # applique SCTransform
  vars.to.regress = "percent.mt", # régresse l'effet des gènes mitochondriaux
  verbose = TRUE # affiche la progression
)
```

# Réduction de dimension, clustering et visualisation
Nous procédons à la réduction de dimension via PCA, puis UMAP pour la visualisation. 
Nous effectuons ensuite le clustering des cellules et identifions les marqueurs de chaque cluster.\\

\textbf{Interprétation PCA:}\\

```{r PCA, message=FALSE, warning=FALSE}
caf <- RunPCA(caf, verbose = FALSE)
DimPlot(caf, reduction = "pca")
```

\textbf{Interprétation TSNE:} \\
```{r TSNE, message=FALSE, warning=FALSE}
ncountsTSNE <- RunTSNE(ncounts, dims=1:10 , perplexity=30)
DimPlot(ncountsTSNE, reduction = "tsne" , label = FALSE )
```


\textbf{Interprétation UMAP:} \\
```{r UMAP, message=FALSE, warning=FALSE}
ncountsUMAP <- RunUMAP(ncounts, dims=1:10)
DimPlot(ncountsUMAP, reduction = "umap" , label=TRUE )

ncountsUMAP<-FindNeighbors(ncountsUMAP,dims=1:10)
ncountsUMAP <- FindClusters ( ncountsUMAP , resolution =0.1)

ncountsUMAP.markers <- FindAllMarkers ( ncountsUMAP , only.pos = TRUE , min.pct =0.25 ,
                                   logfc.threshold =0.25)
ncountsUMAP.markers %>%
  group_by ( cluster ) %>%
  slice_max ( n =2 , order_by = avg_log2FC )
```


\textbf{Interprétation Clustering:} \\

Chaque ligne correspond à une famille d'origine différente.
La première représente les VSMC, la seconde ligne correspont a HSC, la troisième ligne représente lesSAMes
```{r Gene d'intéret, message=FALSE, warning=FALSE}
signatureGene <- c(
  "PLN","SORBS2","PHLDA2","SNCG","MT1M","MYH11",
  "PTGDS","FBLN1","DCN","LUM","COL1A1","LTBP2",
  "FABP5","HIGD1B","AGT","RGS5","CPE","SSTR2"
)
```


```{r marqueur, message=FALSE, warning=FALSE}
signatureGeneMarker <- ncountsUMAP.markers %>%
  dplyr::filter(gene %in% signatureGene)
signatureGeneMarker$gene <- factor(signatureGeneMarker$gene, levels = signatureGene)

signatureGeneMarker <- signatureGeneMarker %>%
  arrange(gene)
```


```{r graphique, message=FALSE, warning=FALSE}
DoHeatmap(ncountsUMAP, features = signatureGene) + NoLegend()

DimPlot(ncountsUMAP, reduction = "umap" , label=TRUE )
FeaturePlot (ncountsUMAP, features = c ("PLN","SORBS2","PHLDA2","SNCG","MT1M","MYH11")) # 6 for each gene
FeaturePlot (ncountsUMAP, features = c ("PTGDS","FBLN1","DCN","LUM","COL1A1","LTBP2")) # 6 for each gene
FeaturePlot (ncountsUMAP, features = c ("FABP5","HIGD1B","AGT","RGS5","CPE","SSTR2")) # 6 for each gene
```



Remarques du prof : 

Toutes les cellules sont des cafs, mais il existe plusieurs sous populations. Si on prends des marqueurs de certains CAFS, probablement ils vont sortir un peu partout, par contre il y'a un peu de différences dans les sous populations. Ce qu'on essaye de coprendre ici c'est les différences entre les CAFS. Ca veut dire on va chercher les genes qui sont dans chaque cluster, et avec cette listes on va voir si il y'a des signatures transcriptionnelles particuleires. C'est des CAF avec ce phénotype, c'est des CAF avec ce phénotypes ...... 

Pour faire cela il faut prendre n gènes squi sont les plus exprimés dans chaque cluster. 
n va utiliser la fonction FindAllMarkers de Seurat pour faire cela. Ce qui est intéressant c'est que Seurat quand on à des données spatiales il nous permet de regarder., par exemple, l'expression d'un gène dans chaque cluster. 
