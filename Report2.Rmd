---
  title: "CAF Single cell Transcriptomics Analysis"
author: "Mickael Coquerelle & Loik Galtier"
date: "`r Sys.Date()`"
output:
  html_document:
  toc: true
toc_depth: 3
theme: cerulean
highlight: tango
df_print: paged
pdf_document:
  toc: true
toc_depth: 3
number_sections: true
header-includes:
  in_header: 
  - \usepackage{amsmath}
- \usepackage{graphicx}
- \usepackage{float}
- \usepackage{hyperref}
- \usepackage{longtable}
- \usepackage{booktabs}
- \usepackage{array}
- \usepackage[french]{babel}
- \usepackage[utf8]{inputenc}
- \usepackage[T1]{fontenc}
geometry: margin=1cm
fontsize: 11pt
linestretch: 1.15
bibliography: []
---
  
  ```{r setup, echo=TRUE, results="hide", message=FALSE, warning=FALSE}
# Setup global chunk options and libraries.
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.width = 8, fig.height = 6)
# Tidyverse-like utilities
library(dplyr)
library(ggplot2)
# Seurat and single-cell specific tools
library(Seurat)
# Parallelization for Seurat (kept sequential by default in this report for reproducibility)
library(future)
# Annotation via Ensembl
library(AnnotationDbi)
library(EnsDb.Hsapiens.v86)
sessionInfo()
# Parallelisation:
plan(sequential) 
options(future.globals.maxSize=10*1024^3) # 10 GB

```

```{r namespace-fix, message=FALSE, warning=FALSE}
# Resolve namespace conflicts (ensembldb::filter masks dplyr::filter)
filter  <- dplyr::filter
arrange <- dplyr::arrange
mutate  <- dplyr::mutate   
select  <- dplyr::select
```


```{r load, echo=TRUE, results="hide", message=FALSE, warning=FALSE}
" data loading : we load the three datasets corresponding to three different patients' CAF single-cell RNA-seq data. "

'p5  <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805570_CountsMatrix_20G00953M_TN.txt.gz",
sep="\t")
p4a <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805568_CountsMatrix_19G02977B_TN.txt.gz",
sep="\t")
p4b <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/GSM4805566_CountsMatrix_19G02977A_TN.txt.gz",
sep="\t")'


p5  <- read.csv("~/Documents/git/Single_Cell_Project/Data/GSM4805570_CountsMatrix_20G00953M_TN.txt.gz",
                sep="\t")
p4a <- read.csv("~/Documents/git/Single_Cell_Project/Data/GSM4805568_CountsMatrix_19G02977B_TN.txt.gz",
                sep="\t")
p4b <- read.csv("~/Documents/git/Single_Cell_Project/Data/GSM4805566_CountsMatrix_19G02977A_TN.txt.gz",
                sep="\t")

```

# Résumé
L'objet de ce travail et de se familiariser avec l'analyse transcriptomique Single-Cell de CAF (Cancer Associated Fibroblasts) à partir d'une matrice de comptages issues des trois fichiers proposé. Notre pipeline d'analyse en se basant sur les éléments donnés en cours couvre le nettoyage (filtrage cellules/gènes), normalisation, réduction de dimension (PCA, t-SNE, UMPAP), clustering, identification de(s) signature(s) transcriptomique(s) pour marquer les clusters et enfin nous proposons une visualisation ciblée par heatmap et features plots.

# Préparation des données.
We combine the three datasets and map Ensembl IDs to gene symbols and types. the objectif is to filter for protein-coding genes with unique symbols and no missing values.
## Pré-processing des données
```{r data-preprocessing, results="hide", message=FALSE, warning=FALSE}
caf.data <- data.matrix(cbind(p5, p4a, p4b))

# Ensembl mapping
'
ens <- read.csv("~/Projets_GIT/Single_Cell_Project/Data/ensembl-38-108-genes.txt", sep="\t")'
ens <- read.csv("~/Documents/git/Single_Cell_Project/Data/ensembl-38-108-genes.txt", sep="\t")
ens2symb <- setNames(ens$Gene.name, ens$Gene.stable.ID)
ens2type <- setNames(ens$Gene.type, ens$Gene.stable.ID)

symbols <- ens2symb[rownames(caf.data)]
types   <- ens2type[rownames(caf.data)]

good <- types == "protein_coding" & !is.na(symbols) & !duplicated(symbols)
symb <- symbols[good]

caf.data <- caf.data[good, ]
rownames(caf.data) <- symb

```

On crée un premier objet SeuratObject pour tirer profit des routines intégrées à la librairie
(FindVariableFeatures, ScaleData, RunPCA, etc.):
  
  ```{r create-seurat-object, results="hide", message=FALSE, warning=FALSE}
caf <- CreateSeuratObject(
  counts = caf.data,
  project = "CAF_raw",
  min.cells = 0.01 * ncol(caf.data),
  min.features = 1000
)
#caf
```

## QC et filtrage des données

Puis on va définir des filtres. La détermination de ces derniers se fait sur des règles d'usage en *single-cell.*
*min.cells = 0.01* au premier passage pour exclures les gènes exprimés dans
très peu de cellules (ici adapté au CreateSeuratObject).
On applique ensuite des QC aux cellules : 
- Les UMIs elevés (>50000) indiquent des duplicats il faut donc les gérer.
- Les cellules avec peu de gènes détectés (< 1000) sont souvent de mauvaise qualité, 
il y'a donc necessité de les filtrer. 
- Ensuite on ajoute une condition pour gérer la proportion de gènes mitochondriaux
élevée (> 50), qui est un indicateur de cellules mortes. 
En combinant ces filtres, on nettoie notre dataset de manière avoir un jeu de cellule
de haute qualité.

```{r qc-filtering, results="hide", message=FALSE, warning=FALSE}
# Identify mitochondrial genes

ensdb.genes <- genes(EnsDb.Hsapiens.v86)
MT.names <- ensdb.genes[seqnames(ensdb.genes) == "MT"]$gene_name
counts <- GetAssayData(caf, "RNA")
umi.tot  <- colSums(counts)
gene.tot <- colSums(counts > 0)
mito.pc  <- colSums(counts[rownames(counts) %in% MT.names, ]) / umi.tot * 100

# Quality filters
bad.high <- umi.tot > 50000
bad.low  <- gene.tot < 1000
bad.mito <- mito.pc > 50
bad <- bad.high | bad.low | bad.mito

# Cleaning
counts <- counts[, !bad]
good.genes <- rowSums(counts > 1) >= 0.01 * ncol(counts)
counts <- counts[good.genes, ]
dim(counts)

```
Nous pouvons visualiser la distribution de la proportion de gènes mitochondriaux, avant nettoyage: 
  
  ```{r histo, message=FALSE, warning=FALSE}
hist(mito.pc, breaks=50)

```

Nous mettons à jour notre objet Seurat avec les données nettoyées :
  ```{r update-seurat-object, results='hide', message=FALSE, warning=FALSE}
caf <- CreateSeuratObject(counts = counts, project = "CAF_clean")
caf[["percent.mt"]] <- PercentageFeatureSet(caf, pattern = "^MT-")

```

# Normalisation avec SC Transform.
La normalisation etant une étape charnière et pouvant grandement changer les résultats finaux en Single-Cell. Nous avons choisi ici d'exploiter les fonctionnalités de normalisation de la librairie Seurat. Plutôt qu'une normalisation CPM (par millions) ou LogNormalize, nous appliquons ici **SCTransform**, une méthode plus moderne et robuste, qui est construite sur un modèle négatif binomial (Hafemeister & Satija, 2019). De ce que nous en avons compris, une telle approche va agir sur plusieurs aspects : 
  - La normalisation par profondeur de séquençage,  
- La stabilisation de variance,  
- La sélection des gènes variables,  
- La correction des effets techniques (ici regression des % mitochondriaux).
Cette méthode est d'après la littérature **la référence Seurat** pour le pré-traitement.

## Le modèle mathématique dérrière la normalisation SCTransform

La normalisation SCTransform repose sur un modèle de **régression négative binomiale**.  
Pour chaque gène \(g\) et chaque cellule \(i\), on suppose : $y_{ig} \sim \text{NB}(\mu_{ig}, \theta_g)$
où \(y_{ig}\) est le nombre de transcripts observés, \(\mu_{ig}\) la moyenne attendue de nos comptes et 
\(\theta_g\) : le paramètre de dispersion du gène \(g\). La moyenne \(\mu_{ig}\) est modélisée via un lien log-linéaire.
\[
\log(\mu_{ig}) = \beta_{0g} + \beta_{1g} \cdot \log(\text{UMI}_i) + \sum_{k} \gamma_{kg} x_{ik}
\]
avec :
- \(\beta_{0g}\) : intercept spécifique au gène \(g\)  
- \(\text{UMI}_i\) : total de counts de la cellule \(i\) (size factor)  
- \(x_{ik}\) : variables techniques à régresser (ex. % mitochondriaux, batch)  
- \(\gamma_{kg}\) : coefficients associés aux covariables
La normalisation finale utilisée pour l'analyse (PCA, clustering) est obtenue via les **résidus Pearson standardisés** :
  \[
    r_{ig} = \frac{y_{ig} - \hat{\mu}_{ig}}{\sqrt{\hat{\mu}_{ig} + \frac{\hat{\mu}_{ig}^2}{\theta_g}}}
    \]

Ces résidus sont **variance-stabilisés** et permettent d'atténuer l'effet de la profondeur de séquençage et du bruit technique.
Avec cette approche, on à \textit{à priori} un modèle individuel pour chaque gène, et une normalisation \og cellule spécifique \fg.

## Application de la méthode
```{r sctransform, message=FALSE, warning=FALSE}
caf <- SCTransform(
  caf,
  vars.to.regress = "percent.mt",
  verbose = TRUE)
```

# Réduction de dimension, clustering et visualisation
Nous procédons à la réduction de dimension via PCA, puis UMAP pour la visualisation. 
Nous effectuons ensuite le clustering des cellules et identifions les marqueurs de chaque cluster.\\

## Interprétation PCA\\

```{r PCA, message=FALSE, warning=FALSE}
caf <- RunPCA(caf, verbose = FALSE)
DimPlot(caf, reduction = "pca")
```
La PCA des cellules CAF nettoyées nous montre ici  un nuage diffus sans clusters franchement identifiable. C'est le reflet d'une grande variabilité plutôt que de sous-populations clairement séparées. On peut expliquer cela en partie par  la diversité des CAF, mais ausis par le fait que la PCA capture surtout la variance linéaire qui est dominante. Avant SCTransform, des effets techniques comme la profondeur de séquençage ou le % mitochondrial peuvent encore masquer la structure biologique réelle. Les signatures transcriptionnels typiques des CAF sont ici illustrés par cette dispersion dans l'espace PCA. Cette première exploration nous confirme la qualité  que des méthodes non linéaires (UMAP, t-SNE) sont necessaires pour que nous allions plus loin dans les investigations.

## Interprétation de l'ElbowPlot\\
```{r elbow, message=FALSE, warning=FALSE}
ElbowPlot(caf)
```
Le graphique ElbowPlot nous montre que les 10 premières composantes principales capturent la majorité de la variance significative dans les données (ce qui parait cohérent avec les notions expliquées en cours). Au-delà de ce seuil, l'ajout de composantes supplémentaires contribue peu à l'explication de la variance totale, on à donc un point d'inflexion clair. Par conséquent, nous choisissons d'utiliser les 10 premières dimensions pour les analyses ultérieures telles que UMAP et t-SNE. Cela nous permet donc de capturer la structure transcriptionnelle des CAF sans intégrer trop de bruit.

## Interprétation TSNE \\

```{r TSNE, message=FALSE, warning=FALSE}
caf_tsne <- RunTSNE(caf, dims = 1:10, perplexity = 30)
DimPlot(caf_tsne, reduction = "tsne")
```
Nous avons vu que le t-SNE est une méthode de réduction non linéaire qui va nous aider à révéler la structure locale des données en essayant de préserver les voisinages cellulaires, contrairement à la PCA qui capture surtout la variance globale (van der Maaten & Hinton, 2008). 

Dans nos caf nettoyés , il va nous permettent d'explorer d'éventuels sous-types tels que les myofibroblast-like ou immunomodulatory CAF (Elyada et al., 2019), ainsi que d'identifier d'éventuels signatures transcriptionnelles de cette population très plastique. En faisant un peu de bibliographie, nous avons cru comprendre que les CAF forment souvent des trajectoires continues plutôt que des clusters séparés, le t-SNE diffus que nous avons iciavec des amas pas clairement délimités est cohérent biologiquement avec ce que nous avons pu lire (Ohlund et al., 2017 - Helms et al., 2022).
Cette absence de clusters bien définis n'est dont à priori pas un problème technique, mais la nature graduelle et hétérogène des CAF dans l'environnement tumoral. En complément de notre PCA et de l'elbow plot, le t-SNE consolide cette idée  d'une organisation continue de cette population fibroblastique. Dans notre démarche pour distinguer des vrais clusters il faut aller donc plus loin.


## Interprétation UMAP et clustering:  \\
```{r UMAP, message=FALSE, warning=FALSE}
caf_umap <- RunUMAP(caf, dims = 1:10)
caf_umap <- FindNeighbors(caf_umap, dims = 1:10)
caf_umap <- FindClusters(caf_umap, resolution = 0.155)

DimPlot(caf_umap, reduction = "umap", label = TRUE)
```

La dernièreméthode que nous avons utiliser est UMAP. "Uniform Manifold Approximation and Projection" (UMAP) se base aussi sur la PCA et permet la réduction de la dimension comme T-SNE. Notons qu' UMAP est plus efficace pour préserver à la fois des structures locales ET globale des données, ce qui se révèle interessant si on chercher à capturer des relations complexes entre les cellules CAF (McInnes et al., 2018: https://arxiv.org/pdf/1802.03426). En appliquant UMAP à nos données CAF nettoyées, nous avons pu visualiser des regroupements cellulaires  mieux séparées par rapport au t-SNE. Ces clusters à brûle-pourpoint permettent d'apercevoir des sous-populations au sein des CAF, en se renseignant brièvement dans la littérature, on peut logiquement poser l'hypothèse  qu'elles sont liées à des fonctions biologiques spécifiques telles que le remodelage de la matrice extracellulaire ou l'immunomodulation (Kalluri, 2016 :10.1038/nrc.2016.73)

\textbf{Interprétation Clustering:} \\

Chaque ligne correspond à une famille d'origine différente.
La première représente les VSMC, la seconde ligne correspont a SAMes, la troisième ligne représente les HSC

```{r Genes_interets, message=FALSE, warning=FALSE}
signatureGene <- c(
  "PLN","SORBS2","PHLDA2","SNCG","MT1M","MYH11",
  "PTGDS","FBLN1","DCN","LUM","COL1A1","LTBP2",
  "FABP5","HIGD1B","AGT","RGS5","CPE","SSTR2")
```
Les VSMC ("*Vascular Smooth Muscle Cells*") sont comme leur nom l'indique des cellules du muscle lisse vasculaire , constituant la paroi des vaisseaux sanguin et du coeur. Si l'expression des VSMC est forte, cela suppose une CAF myofibroblastiques d'origine (peri)vasculaire.

Les HSC ("*Hepatic Stellate Cells*") sont des cellules "étoilé" présentes dans le foie, dans l'espace de Disse. Lors d'un traumatisme, elles peuvent produire du collagène. Si l'expression est forte, cela pourrait indiquer un cancer du foie et un CAF pro-tumorigéniques d'origine HSC (Affò et al., 2013)
Les SAMes sont des cellules regroupant les fibroplastes et les mesenchymales qui se trouvent dans le foie. Si l'expression est forte, cela suppose une origine cicatriciel (https://doi.org/10.1073/pnas.140006211) )(https://www.mdpi.com/1422-0067/20/7/1723)


```{r marqueur, message=FALSE, warning=FALSE}
caf_markers <- FindAllMarkers(
  caf_umap,
  only.pos = TRUE,
  min.pct  = 0.25,
  logfc.threshold = 0.25)

caf_markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_log2FC)
```


```{r sign,message= FALSE , warning=FALSE}
signatureGene <- c(
  "PLN","SORBS2","PHLDA2","SNCG","MT1M","MYH11",
  "PTGDS","FBLN1","DCN","LUM","COL1A1","LTBP2",
  "FABP5","HIGD1B","AGT","RGS5","CPE","SSTR2")

signatureGeneMarker <- caf_markers %>%
  filter(gene %in% signatureGene) %>%
  mutate(gene = factor(gene, levels = signatureGene)) %>%
  arrange(gene)
```


```{r go, message=FALSE, warning=FALSE}
# 
library(clusterProfiler)
library(org.Hs.eg.db)
library(dplyr)

all_genes <- rownames(caf_umap)

universe_entrez <- bitr(all_genes,
                        fromType = "SYMBOL",
                        toType = "ENTREZID",
                        OrgDb = org.Hs.eg.db) %>% pull(ENTREZID)


mat <- GetAssayData(caf_umap, slot = "data")
cluster_list <- unique(Idents(caf_umap))

print(cluster_list)

enrich_results <- list()

for(cl in cluster_list)
{
  cells_cl <- WhichCells(caf_umap, idents = cl)
  
  mat_cl <- mat[, cells_cl, drop = FALSE]
  
  sig_detected <- signatureGene[rowSums(mat_cl[signatureGene, ,drop = FALSE] > 0) > 0]
  print(sig_detected)
  
  sig_entrez <- bitr(sig_detected,
                     fromType = "SYMBOL",
                     toType = "ENTREZID",
                     OrgDb = org.Hs.eg.db) %>% pull(ENTREZID)
  
  
  if(length(sig_entrez) > 0)
  {
    ego_sig <- enrichGO(
      gene = sig_entrez,
      universe = universe_entrez,
      OrgDb = org.Hs.eg.db,
      ont = "BP",
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.05,
      readable = TRUE
    )
    
    enrich_results[[as.character(cl)]] <- ego_sig
  }
  
}


for (cl in names(enrich_results)) {
  print(dotplot(enrich_results[[cl]], showCategory = 10) + ggtitle(paste0("cluster ", cl)))
}


```

```{r graphique, message=FALSE, warning=FALSE}
DoHeatmap(caf_umap, features = signatureGene) + NoLegend()
```
L'analyse de l'expression des gènes représentée à l'aide de la Heatmap vu en cours nous permet de mettre en évidence une hétérogénéité transcriptionnelle notable au sein des fibroblastes cancéreux. 

Plusieurs sous-populations émergent avec des profils d'expression distincts, cela vient consolider l'idée comme pour la l'UMAP que les cellules ne constituent pas un bloc fonctionnel homogène mais plutôt un ensemble de programmes d'activation différenciés, cette constatation plus intuitive sur la Heatmap que le graphique précédent. Nous avons des signatures sans équivoques et d'autres plus surprenantes, regardons un peu plus en détail.

**Cluster 0**, l'hypothèse des CAF neuro-endocrine et VSMC-like
On a ici une expression franche de FABP5, HIGD1B, AGT, RGS5, CPE, SSTR2, combinant marqueurs contractiles, sécrétoires et métaboliques. RGS5 et SSTR2 suggèrent une origine périvasculaire des cellules (des péricytes), tandis qu'on peut se dire qu' AGT et CPE signe un  potentiel rôle paracrine/hormonal  des cellules dans la modulation vasculaire et/ou immunitaire. Au regard de nos (maigres) connaissances  sur les CAF, nous pensons que ce premier  cluster illustre une grande plasticité des CAF pour s'adapter à l'environnement. (Guo et Xu, 2024: DOI:10.1007/s10555-024-10186-7)

**Cluster 1** , CAF ECM-remodeling
PTGDS, FBLN1, DCN, LUM, COL1A1, LTBP2 indiquent une activité dominante de production et d'organisation de la matrice extracellulaire. Ce phénotype, est typique des CAF dit "matrix-remodeling", contribue à la rigidification stromale et contribue à l'invasion tumorale.(Belhabib et al.,2021 : DOI : 10.3390/cancers13143466)

**Cluster 2**, CAF contractile et VSMC-like
PLN, SORBS2, PHLDA2, SNCG, MT1M, MYH11 reflètent un phénotype contractile proche des cellules musculaires lisses. Ces CAF, semblables à des myCAFs ou d'origine vasculaire, pourraient remodeler mécaniquement la matrice et influencer la prolifération anarchique des cellules et donc la perfusion tumoral, pour se répendre.

**Cluster 3** et CAF mixte / ECM-remodeling + métabolique
Pour ce dernier cluster, nous avons les gènes les plus exprimés DCN, LUM, COL1A1, LTBP2, FABP5, nous pensons qu'il s'agit ici d'un état, disons, intermédiaire : une production de matrice combinée à une adaptation métabolique, c'est peut être une population intermédiaire qui permet de répondre aux signaux du microenvironnement (https://pubmed.ncbi.nlm.nih.gov/40940809/).

Pour conclure sur cette stratification nous voulons ajouter quelques limites qui sont selon nous à intégrer pour interpréter avec prudence ce graphique (et les précédents). La mise en évidence de sous-types repose sur les gènes sélectionnés et sur des algorithmes de réduction dimensionnelle, ce qui limite le champ d'étude à nos choix personnels (soit dit en passant peut être pas les plus pertinents) .

Par ailleurs, en fin de cours vous nous avez mentionné que l'expression génique ne préjuge pas directement (forcément) de l'activité fonctionnelle in vivo, et une validation par des analyses complémentaires du type  signalisation ligand-récepteur, ou encore données protéomiques, serait nécessaire pour consolider nos observations et dépasser, évidemment, l'approche exploratoire que nous avons ici.

Pour conclure, nous pensons malgré tout que  cette visualisation est une photographie assez pertinente de l'hétérogénéité des CAF,  sans pour autant nier l'importance d'approches intégratives pour comprendre son rôle dans le microenvironnement tumoral.

```{r FeaturePlots, message=FALSE, warning=FALSE}
# FeaturePlots par famille
FeaturePlot(caf_umap, features = c("PLN","SORBS2","PHLDA2","SNCG","MT1M","MYH11"))
FeaturePlot(caf_umap, features = c("PTGDS","FBLN1","DCN","LUM","COL1A1","LTBP2"))
FeaturePlot(caf_umap, features = c("FABP5","HIGD1B","AGT","RGS5","CPE","SSTR2"))
```



